= Contagem de objetos
:source-highlighter: pygments
Fellipe Leandro <faugusto12@gmail.com>


== Definição do problema
O problema consiste em determinar a quantidade de objetos em uma cena. No caso em questão, os objetos assumem o formato de bolhas. Deve-se sugerir um algoritmo de processamento digital de imagens para realizar a contagem das bolhas.

== Solução proposta

A solução proposta baseia-se no algoritmo _seedFill_ ou _floodfill_

.Cena com objetos a serem contados
image::imgs/bolhas.png[]

.main.cpp
[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>
using namespace cv;
using namespace std;

int main()
{
    Mat image;
    int width,height;
    int nobj=0;
    int fila[80][2]={0};
    int fila_pos=0;
    int contfilaPos=0;
    image = imread("bolhas.png",CV_LOAD_IMAGE_GRAYSCALE);
    if(!image.data)
        cout<<"Nao abriu imagem"<<endl;
    namedWindow("janela1",WINDOW_AUTOSIZE);
    imshow("janela1", image);
    //waitKey();

    width = image.size().width;
    height = image.size().height;
    for(int i=0;i<height;i++){
        for(int j=0;j<width;j++){
            if(image.at<uchar>(i,j)==255){ //pixel encontrado é branco
                contfilaPos=0; //primeira posição da fila
                fila_pos=0;
                nobj++;       //mais um objeto encontrado
                fila[fila_pos][0]=i; //primeiro elemento da  fila: semente
                fila[fila_pos][1]=j;
                image.at<uchar>(fila[fila_pos][0],(fila[fila_pos][1]))=60; //rotular ponto, mudando-o de cor
                while(fila[0][0]!=-1){ //começar a busca por vizinhos (4-vizinhos)

                    if(image.at<uchar>(fila[fila_pos][0],fila[fila_pos][1]-1)==255){ //vizinho da esquerda
                        image.at<uchar>(fila[fila_pos][0],(fila[fila_pos][1]-1))=15;
                        //fila_pos++;
                        contfilaPos++; //final da fila
                        fila[contfilaPos][0]=fila[fila_pos][0]; //guardar posição do vizinho no final da fila
                        fila[contfilaPos][1]=fila[fila_pos][1]-1;
                    }
                    if(image.at<uchar>(fila[fila_pos][0],(fila[fila_pos][1]+1))==255){ //vizinho da direita
                        //mudar cor
                        image.at<uchar>(fila[fila_pos][0],(fila[fila_pos][1]+1))=15;
                        //fila_pos++;
                        contfilaPos++;
                        fila[contfilaPos][0]=fila[fila_pos][0];
                        fila[contfilaPos][1]=fila[fila_pos][1]+1;
                    }
                    if(image.at<uchar>(fila[fila_pos][0]+1,fila[fila_pos][1])==255){ //vizinho de cima

                        //mudar cor
                        image.at<uchar>(fila[fila_pos][0]+1,fila[fila_pos][1])=15;
                        //fila_pos++;
                        contfilaPos++;
                        fila[contfilaPos][0]=fila[fila_pos][0]+1;
                        fila[contfilaPos][1]=fila[fila_pos][1];

                    }
                    if(image.at<uchar>(fila[fila_pos][0]-1,fila[fila_pos][1])==255){ //vizinho de baixo
                        //mudar cor
                        image.at<uchar>(fila[fila_pos][0]-1,fila[fila_pos][1])=15;
                        //fila_pos++
                        contfilaPos++;
                        fila[contfilaPos][0] = fila[fila_pos][0]-1;
                        fila[contfilaPos][1] = fila[fila_pos][1];
                    }
                    for(int aux=0;aux<contfilaPos&&aux<79;aux++){ //esse for implementa um 'pop' na fila. O vizinho passa  a ser nova semente
                        if(aux==70){
                            cout<<"Perigo"<<endl;
                        }
                        fila[aux][0]=fila[aux+1][0];
                        fila[aux][1]=fila[aux+1][1];

                    }
                    for(int aux1=contfilaPos;aux1<80;aux1++){ //gambiarra para o while
                            fila[aux1][0]=-1;
                            fila[aux1][1]=-1;

                        }
                    contfilaPos--; //para não pular uma posição na fila quando começar a proxima iteração
                    }


                }

            }

        }
    namedWindow("janela",WINDOW_AUTOSIZE);
    imshow("janela", image);
    imwrite("fill.png", image);
    waitKey();
    cout<<"Numero de bolhas: "<<nobj<<endl;
        return 0;
    }

----
